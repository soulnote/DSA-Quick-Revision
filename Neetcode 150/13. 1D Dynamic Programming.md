## 70\. Climbing Stairs

**Climbing Stairs** ek classic Dynamic Programming problem hai jismein humein ek staircase ko climb karne ke unique ways count karne hote hain.

-----

### Description/Overview

Imagine karo aapko ek staircase climb karni hai jismein `n` steps hain. Har baar aap ya toh **1 step** upar ja sakte ho ya **2 steps** upar ja sakte ho. Aapko find karna hai ki kitne **distinct ways** se aap top tak pahunch sakte ho.

For example:

  * Agar `n = 2`: Ways hain (1, 1) aur (2). Total 2 ways.
  * Agar `n = 3`: Ways hain (1, 1, 1), (1, 2), aur (2, 1). Total 3 ways.

Notice, this problem is very similar to finding the Nth Fibonacci number\!

### Approach (How to do it)

This problem has optimal substructure and overlapping subproblems, which are hallmarks of Dynamic Programming.

1.  **Base Cases:**

      * Agar `n = 1` hai, toh sirf 1 way hai (1 step).
      * Agar `n = 2` hai, toh 2 ways hain (1, 1) aur (2).

2.  **Recursive Relation (Intuition):**

      * Agar aap `n` steps tak pahunchna chahte ho, toh aapko **second-to-last step (n-1)** se 1 step lena hoga, ya **third-to-last step (n-2)** se 2 steps lene honge.
      * Iska matlab, `ways(n) = ways(n-1) + ways(n-2)`.
      * Yeh exact Fibonacci sequence hai\!

3.  **Dynamic Programming (Bottom-Up):**

      * Ek DP array `dp` banao jismein `dp[i]` store karega `i` steps tak pahunchne ke ways.
      * `dp[1] = 1`
      * `dp[2] = 2`
      * Loop `i` from `3` to `n`: `dp[i] = dp[i-1] + dp[i-2]`.
      * Finally, `dp[n]` return karo.

4.  **Optimization (Space Complexity):**

      * Kyunki `dp[i]` sirf `dp[i-1]` aur `dp[i-2]` par depend karta hai, hum poora array store karne ki bajaye sirf do variables use kar sakte hain: `prev1` aur `prev2`.

### Solution (The Way to Solve)

Hum bottom-up Dynamic Programming approach ka use karte hain. Ek array `dp` maintain karte hain jahan `dp[i]` `i` steps climb karne ke tareeqe batata hai. `dp[1]` ko 1 aur `dp[2]` ko 2 set karte hain. Fir loop chala kar `dp[i] = dp[i-1] + dp[i-2]` calculate karte hain `i = 3` se `n` tak. Yeh Fibonacci sequence jaisa hi hai. Space optimize karne ke liye, hum sirf pichle do values ko track karte hain.

### Code

```java
class Solution {
    public int climbingStairs(int n) {
        // Base cases
        if (n == 0) {
            return 0; // No steps, no ways (or depends on problem definition, usually 1 for 0 steps)
                      // Given constraints for n >= 1, this case might not be hit.
        }
        if (n == 1) {
            return 1; // 1 step: (1)
        }

        // DP array to store ways for i steps
        // int[] dp = new int[n + 1];
        // dp[1] = 1;
        // dp[2] = 2;

        // Optimized space: only need previous two values
        int prev1 = 2; // Ways to reach step 2
        int prev2 = 1; // Ways to reach step 1
        int currentWays = 0;

        for (int i = 3; i <= n; i++) {
            // dp[i] = dp[i-1] + dp[i-2]
            currentWays = prev1 + prev2;
            prev2 = prev1;   // Shift prev1 to prev2
            prev1 = currentWays; // Current becomes new prev1
        }

        // return dp[n];
        return prev1; // prev1 will hold ways for 'n' steps
    }
}
```

-----

## 746\. Min Cost Climbing Stairs

**Min Cost Climbing Stairs** ek Dynamic Programming problem hai jismein humein stairs ke top tak pahunchne ka minimum cost find karna hota hai.

-----

### Description/Overview

Aapko ek integer array `cost` diya gaya hai, jahan `cost[i]` hai `i-th` step par chadhne ka cost. Aap ya toh step `0` se ya step `1` se start kar sakte ho. Har step par, aap ya toh ek ya do steps upar chadh sakte ho. Aapko staircase ke top tak pahunchne ka **minimum cost** return karna hai.

For example:

  * `cost = [10, 15, 20]`

      * Option 1: Start at `cost[0]`, take 2 steps -\> `cost[0]` (10) -\> top. Total cost = 10.
      * Option 2: Start at `cost[1]`, take 2 steps -\> `cost[1]` (15) -\> top. Total cost = 15.
      * Minimum cost = 10.

  * `cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]`

      * Answer: 6 (Start at cost[0], then skip 100, take 1, skip 100 etc. (1 + 1 + 1 + 1 + 1 + 1 = 6))

### Approach (How to do it)

This is a DP problem because we can find the minimum cost to reach a step by knowing the minimum cost to reach the previous two steps.

1.  **Define `dp` array:** Let `dp[i]` be the minimum cost to reach step `i`.

2.  **Base Cases:**

      * `dp[0] = cost[0]` (Cost to reach step 0 is `cost[0]`)
      * `dp[1] = cost[1]` (Cost to reach step 1 is `cost[1]`)
      * Note: Top of the stairs is actually *after* the last element in the `cost` array. So, we're calculating min cost to reach `n` steps, where `n` is `cost.length`.

3.  **Recursive Relation:**

      * `dp[i] = cost[i] + min(dp[i-1], dp[i-2])`
      * Yeh formula tab apply hoga jab `i`th step par *chadhne* ka cost consider kar rahe hain.
      * Lekin yahan question mein thoda ambiguity ho sakti hai: is `dp[i]` cost *to reach* step `i` OR cost *to land on* step `i` and then continue?
      * The common interpretation is: `dp[i]` is the minimum cost to reach a point *just after* step `i-1` and then decide to go to step `i` or `i+1`.
      * A better DP state definition: `dp[i]` represents the minimum cost to reach the *i-th* step, with the goal being to reach step `n`.
      * `dp[i]` = Minimum cost to reach **the top of the staircase starting from step `i`**.
          * `dp[i] = cost[i] + min(dp[i+1], dp[i+2])` (Bottom-up, but starting from the end)
      * OR, `dp[i]` = Minimum cost to reach **step `i`**.
          * `dp[0] = 0` (cost to reach just before first step)
          * `dp[1] = 0` (cost to reach just before second step)
          * For `i` from `2` to `n`: `dp[i] = cost[i-1] + dp[i-1]` (if coming from `i-1`) OR `cost[i-2] + dp[i-2]` (if coming from `i-2`).
          * **Corrected DP state:** `dp[i]` will be the minimum cost to reach step `i`.
              * `dp[0] = 0` (Cost to reach step 0, assuming you start *before* step 0, or it's the cost of reaching the "ground" before the first step)
              * `dp[1] = 0` (Cost to reach step 1, assuming you start *before* step 1)
              * Or even simpler: `dp[i]` = min cost to reach index `i` (meaning you've paid the cost to get on it). The total length of array is `n`. We want to reach `n`.
              * `dp[i]` = min cost to reach `i` steps. `dp` array will be `n+1` size.
              * `dp[0] = 0`
              * `dp[1] = 0`
              * `dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])` for `i` from 2 to `n`.
              * Finally, `dp[n]` will be the answer.

4.  **Space Optimization:** Similar to Climbing Stairs, we only need the previous two `dp` values.

### Solution (The Way to Solve)

Hum ek `dp` array banate hain jismein `dp[i]` ka matlab hai step `i` tak pahunchne ka minimum cost. `dp` array ki size `cost.length + 1` hogi, jahan `dp[cost.length]` final top step ka minimum cost hoga.
Base cases `dp[0] = 0` aur `dp[1] = 0` set karte hain (kyunki aap ya toh step 0 ya step 1 se start kar sakte ho, jiska initial cost 0 hai before you pay for the first step).
Loop mein `i = 2` se `cost.length` tak iterate karte hain, aur `dp[i]` calculate karte hain as `min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`. `cost[i-1]` means we are arriving at step `i` *from* step `i-1`, paying `cost[i-1]`.
Finally, `dp[cost.length]` return karte hain. Space optimize karne ke liye, `prev1` aur `prev2` variables use kar sakte hain.

### Code

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;

        // DP array to store min cost to reach step i
        // dp[i] will be the minimum cost to reach step i
        // int[] dp = new int[n + 1];

        // Base cases
        // dp[0] = 0; // Cost to reach step 0 (or before starting)
        // dp[1] = 0; // Cost to reach step 1 (or before starting)

        // Optimized space variables
        int dp_i_minus_2 = 0; // Represents dp[i-2]
        int dp_i_minus_1 = 0; // Represents dp[i-1]
        int current_dp_i = 0;

        // Loop from step 2 up to the 'n' (top) step
        for (int i = 2; i <= n; i++) {
            // Cost if coming from step (i-1)
            // We are at step (i-1) and paying cost[i-1] to move to step i
            int costFromOneStepBack = dp_i_minus_1 + cost[i - 1];

            // Cost if coming from step (i-2)
            // We are at step (i-2) and paying cost[i-2] to move to step i
            int costFromTwoStepsBack = dp_i_minus_2 + cost[i - 2];

            // dp[i] = minimum of these two options
            // dp[i] = Math.min(costFromOneStepBack, costFromTwoStepsBack);
            current_dp_i = Math.min(costFromOneStepBack, costFromTwoStepsBack);

            // Shift values for next iteration
            dp_i_minus_2 = dp_i_minus_1;
            dp_i_minus_1 = current_dp_i;
        }

        // The final result is the min cost to reach the 'n' step (top)
        // return dp[n];
        return dp_i_minus_1;
    }
}
```

-----

## 198\. House Robber

**House Robber** ek Dynamic Programming problem hai jismein humein adjacent houses ko lootne se bachne ke liye maximum amount calculate karna hota hai.

-----

### Description/Overview

Aap ek street par ho jahan houses ki ek row hai. Har house mein kuch amount of money hai. Aapko ek plan banana hai jisse aap **maximum amount** loot sako, lekin ek condition hai: **adjacent houses ko loot nahi sakte**. Matlab, agar aap house `i` ko loot te ho, toh aap house `i-1` aur house `i+1` ko loot nahi sakte.

For example:

  * `nums = [1, 2, 3, 1]`

      * Option 1: Loot house 1 (1) + house 3 (3) = 4
      * Option 2: Loot house 2 (2) + house 4 (1) = 3
      * Max amount = 4.

  * `nums = [2, 7, 9, 3, 1]`

      * Option 1: Loot house 1 (2) + house 3 (9) + house 5 (1) = 12
      * Option 2: Loot house 2 (7) + house 4 (3) = 10
      * Max amount = 12.

### Approach (How to do it)

This problem exhibits optimal substructure and overlapping subproblems.

1.  **Define `dp` array:** Let `dp[i]` be the maximum amount of money you can rob from houses `0` to `i`.

2.  **Base Cases:**

      * If `nums.length == 0`, return `0`.
      * If `nums.length == 1`, return `nums[0]`.
      * `dp[0] = nums[0]` (Max amount from house 0 is just its value)
      * `dp[1] = max(nums[0], nums[1])` (Max amount from houses 0 and 1 is the max of their individual values, since you can't rob both)

3.  **Recursive Relation:**

      * For `i` from `2` to `n-1`:
      * To calculate `dp[i]`, aapke paas do choices hain:
          * **Choice 1: Rob house `i`**: Agar aap house `i` ko loot te ho, toh aap house `i-1` ko loot nahi sakte. Toh aapko previous maximum amount `dp[i-2]` se add karna hoga. `nums[i] + dp[i-2]`.
          * **Choice 2: Don't rob house `i`**: Agar aap house `i` ko loot te nahi ho, toh `dp[i]` simply `dp[i-1]` ke barabar hoga.
      * So, `dp[i] = max(nums[i] + dp[i-2], dp[i-1])`.

4.  **Final Result:** `dp[n-1]` (Maximum amount from all houses up to `n-1`).

5.  **Space Optimization:** We only need `dp[i-1]` and `dp[i-2]` to calculate `dp[i]`, so we can optimize space to `O(1)`.

### Solution (The Way to Solve)

Hum ek `dp` array banate hain jahan `dp[i]` ka matlab hai `i`th house tak lootne ka maximum amount. Base cases handle karte hain 0 aur 1 house ke liye. Fir `i = 2` se `n-1` tak loop chala kar, `dp[i]` ko do choices ke maximum par set karte hain: ya toh current house `i` ko loot kar `dp[i-2]` add karo, ya current house ko chhod kar `dp[i-1]` tak ka max amount lo. Final answer `dp[n-1]` hoga. Space optimization ke liye, hum sirf `prev1` (for `dp[i-1]`) aur `prev2` (for `dp[i-2]`) variables use karte hain.

### Code

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;

        // Base cases
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }

        // DP array (can be optimized to O(1) space)
        // int[] dp = new int[n];

        // dp[0] = nums[0];
        // dp[1] = Math.max(nums[0], nums[1]);

        // Optimized space variables
        int prev2 = nums[0]; // Represents dp[i-2]
        int prev1 = Math.max(nums[0], nums[1]); // Represents dp[i-1]
        int currentMax = 0;

        // Iterate from the third house (index 2)
        for (int i = 2; i < n; i++) {
            // Choice 1: Rob current house (nums[i]) + max from 2 houses back (dp[i-2])
            int option1 = nums[i] + prev2;
            // Choice 2: Don't rob current house, take max from previous house (dp[i-1])
            int option2 = prev1;

            // dp[i] = Math.max(option1, option2);
            currentMax = Math.max(option1, option2);

            // Shift values for next iteration
            prev2 = prev1;
            prev1 = currentMax;
        }

        // return dp[n-1];
        return prev1; // prev1 will hold the max amount for 'n-1' houses
    }
}
```

-----

## 213\. House Robber II

**House Robber II** House Robber ka extension hai, jismein houses circular arrangement mein hote hain, aur first aur last house adjacent ban jate hain.

-----

### Description/Overview

Yeh problem House Robber jaisa hi hai, lekin ek twist hai: saare houses **circularly arranged** hain. Iska matlab hai ki **first house aur last house ko bhi adjacent mana jayega**. Is condition ke karan, aap first house aur last house ko **ek saath loot nahi sakte**.

For example:

  * `nums = [2, 3, 2]`

      * If you rob house 1 (2), you can't rob house 2 (3). Max = 2.
      * If you rob house 2 (3), you can't rob house 1 (2) or house 3 (2). Max = 3.
      * If you rob house 3 (2), you can't rob house 2 (3). Max = 2.
      * Answer = 3. (If you rob 3, you cannot rob 2. You also cannot rob 2 and then 2. So you either rob 2+2=4 or 3. Oh wait, this example is slightly tricky. If you rob 2, you can't rob 3. If you rob the other 2, you can't rob 3. So 2+2=4 is possible. But in this specific example, robbing 3 is the max. Let's re-evaluate:
          * Rob house 0 (2). Can't rob 1 or 2. Total 2.
          * Rob house 1 (3). Can't rob 0 or 2. Total 3.
          * Rob house 2 (2). Can't rob 1 or 0. Total 2.
            The example `[2,3,2]` gives output 3. This means you can't rob both `nums[0]` and `nums[n-1]`.
      * The solution should be max(rob(houses excluding last), rob(houses excluding first)).
      * For `[2,3,2]`:
          * Case 1 (exclude last): `[2,3]`. Max rob = `max(2,3) = 3`.
          * Case 2 (exclude first): `[3,2]`. Max rob = `max(3,2) = 3`.
          * Overall max = `max(3,3) = 3`. This seems correct.

  * `nums = [1, 2, 3, 1]`

      * Case 1 (exclude last): `[1, 2, 3]`. Max rob from these = `max(1+3, 2) = 4`.
      * Case 2 (exclude first): `[2, 3, 1]`. Max rob from these = `max(2+1, 3) = 3`.
      * Overall max = `max(4, 3) = 4`.

### Approach (How to do it)

Since the first and last houses are connected, you cannot rob both. This splits the problem into two independent cases:

1.  **Case 1: Rob the first house (`nums[0]`), and therefore CANNOT rob the last house (`nums[n-1]`)**.

      * In this case, you solve the House Robber problem for the subarray `nums[0]` to `nums[n-2]` (i.e., `nums.subArray(0, n-1)` in Java, which means elements from index 0 up to `n-2` inclusive).

2.  **Case 2: DON'T rob the first house (`nums[0]`), and therefore CAN rob the last house (`nums[n-1]`)**.

      * In this case, you solve the House Robber problem for the subarray `nums[1]` to `nums[n-1]` (i.e., `nums.subArray(1, n)` in Java, which means elements from index 1 up to `n-1` inclusive).

The final answer will be the maximum of the results from these two cases.

**Edge Cases:**

  * If `nums.length == 0`, return `0`.
  * If `nums.length == 1`, return `nums[0]`.

You can use the same `rob` function from Problem 198 for these two subproblems.

### Solution (The Way to Solve)

Circular arrangement ke karan, hum first aur last house ko simultaneously loot nahi sakte. Isliye, hum problem ko do subproblems mein divide karte hain:

1.  **Exclude last house:** `nums` array ke houses `0` se `n-2` tak ka maximum amount loot lo.
2.  **Exclude first house:** `nums` array ke houses `1` se `n-1` tak ka maximum amount loot lo.

In dono cases ka maximum result hi final answer hoga. Hum Problem 198 (House Robber) ka solution logic reuse kar sakte hain ek helper function bana kar jo ek given range ke houses ke liye maximum loot calculate kare. Edge cases for `n=0` or `n=1` handle karna important hai.

### Code

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;

        // Base cases
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }

        // Case 1: Exclude the last house (rob houses from 0 to n-2)
        // Create a temporary array for this case
        int[] numsExcludeLast = new int[n - 1];
        System.arraycopy(nums, 0, numsExcludeLast, 0, n - 1);
        int maxRobExcludeLast = robSimple(numsExcludeLast);

        // Case 2: Exclude the first house (rob houses from 1 to n-1)
        // Create a temporary array for this case
        int[] numsExcludeFirst = new int[n - 1];
        System.arraycopy(nums, 1, numsExcludeFirst, 0, n - 1);
        int maxRobExcludeFirst = robSimple(numsExcludeFirst);

        // The result is the maximum of these two cases
        return Math.max(maxRobExcludeLast, maxRobExcludeFirst);
    }

    // This is the same logic as House Robber (Problem 198)
    // It calculates the maximum amount from a linear array of houses
    private int robSimple(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }

        int prev2 = nums[0]; // Represents dp[i-2]
        int prev1 = Math.max(nums[0], nums[1]); // Represents dp[i-1]
        int currentMax = 0;

        for (int i = 2; i < n; i++) {
            int option1 = nums[i] + prev2; // Rob current house
            int option2 = prev1;          // Don't rob current house
            currentMax = Math.max(option1, option2);

            prev2 = prev1;
            prev1 = currentMax;
        }
        return prev1;
    }
}
```

-----

## 5\. Longest Palindromic Substring

**Longest Palindromic Substring** ek Dynamic Programming problem hai jismein humein ek given string ka longest palindromic substring find karna hota hai.

-----

### Description/Overview

Aapko ek string `s` diya gaya hai. Aapko `s` ka **longest palindromic substring** return karna hai.
A substring is a contiguous non-empty sequence of characters within a string.
A palindrome reads the same forwards and backwards.

For example:

  * `s = "babad"`
      * Output: `"bab"` (or `"aba"`, both are valid longest palindromic substrings)
  * `s = "cbbd"`
      * Output: `"bb"`

### Approach (How to do it)

This problem can be solved using Dynamic Programming, expanding around center, or even Manacher's Algorithm for linear time (but DP is more common for initial understanding).

**Dynamic Programming Approach:**

1.  **Define `dp` table:**

      * `boolean[][] dp = new boolean[n][n]` where `n` is `s.length()`.
      * `dp[i][j]` will be `true` if the substring `s[i...j]` is a palindrome, `false` otherwise.

2.  **Base Cases:**

      * **Single characters:** Har single character ek palindrome hota hai.
          * `dp[i][i] = true` for all `i` from `0` to `n-1`.
      * **Two characters:** Agar `s[i] == s[i+1]`, toh `s[i...i+1]` ek palindrome hai.
          * `dp[i][i+1] = true` if `s.charAt(i) == s.charAt(i+1)`.

3.  **Recursive Relation:**

      * For a substring `s[i...j]` to be a palindrome, do conditions honi chahiye:
        1.  `s.charAt(i)` must be equal to `s.charAt(j)`.
        2.  The inner substring `s[i+1...j-1]` must also be a palindrome.
      * So, `dp[i][j] = (s.charAt(i) == s.charAt(j)) && dp[i+1][j-1]`.
      * Hum `gap` (length) ke basis par iterate karenge. `gap` `0` se `n-1` tak jayega.
          * `gap = 0`: `dp[i][i] = true`
          * `gap = 1`: `dp[i][i+1] = (s.charAt(i) == s.charAt(i+1))`
          * `gap = 2` to `n-1`: `dp[i][j] = (s.charAt(i) == s.charAt(j)) && dp[i+1][j-1]`

4.  **Tracking the Longest Palindrome:**

      * Jab bhi `dp[i][j]` `true` ho, check karo ki `j - i + 1` current `maxLength` se bada hai ya nahi.
      * Agar bada hai, toh `maxLength = j - i + 1` aur `start = i` update karo.

### Solution (The Way to Solve)

Hum ek 2D boolean array `dp[i][j]` banate hain jo indicate karta hai ki substring `s[i...j]` palindrome hai ya nahi. Hum is table ko `gap` (substring length) ke basis par fill karte hain, starting from length 1. Length 1 ke substrings (single characters) always palindromes hote hain. Length 2 ke substrings tab palindromes hote hain jab unke do characters same hon. Higher length ke substrings `s[i...j]` tab palindromes hote hain jab `s.charAt(i) == s.charAt(j)` ho aur inner substring `s[i+1...j-1]` bhi palindrome ho (i.e., `dp[i+1][j-1]` is true). Jaise-jaise `dp` table fill hota hai, hum longest palindrome ke `start` index aur `maxLength` ko track karte hain. Finally, `s.substring(start, start + maxLength)` return karte hain.

### Code

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        if (n < 2) {
            return s; // Single char or empty string is a palindrome
        }

        // dp[i][j] will be true if substring s[i...j] is a palindrome
        boolean[][] dp = new boolean[n][n];

        int maxLength = 1; // Minimum length is 1 (single character)
        int startIndex = 0; // Starting index of the longest palindrome found

        // Base case: All single characters are palindromes
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }

        // Base case: Check for palindromes of length 2
        for (int i = 0; i < n - 1; i++) {
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                maxLength = 2;
                startIndex = i;
            }
        }

        // Fill the DP table for lengths 3 to n
        // 'len' represents the current length of the substring
        for (int len = 3; len <= n; len++) {
            // 'i' represents the starting index of the substring
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1; // 'j' is the ending index of the substring

                // A substring s[i...j] is a palindrome if:
                // 1. Its outer characters s[i] and s[j] are the same
                // 2. The inner substring s[i+1...j-1] is also a palindrome
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    // If this new palindrome is longer than the current max
                    if (len > maxLength) {
                        maxLength = len;
                        startIndex = i;
                    }
                }
            }
        }

        // Return the longest palindromic substring
        return s.substring(startIndex, startIndex + maxLength);
    }
}
```

-----

## 647\. Palindromic Substrings

**Palindromic Substrings** ek Dynamic Programming problem hai jismein humein ek given string ke saare palindromic substrings ko count karna hota hai.

-----

### Description/Overview

Aapko ek string `s` diya gaya hai. Aapko `s` ke andar ke **saare palindromic substrings** ki total count find karni hai.
Substring contiguous characters ka sequence hota hai.
Palindromes read the same forwards and backwards.
Important: Different start/end indices ke saath same characters wale substrings ko different count kiya jayega. (e.g., "aaa" has "a" at index 0, "a" at index 1, "a" at index 2, "aa" at index 0, "aa" at index 1, "aaa" at index 0 -\> total 6 palindromic substrings)

For example:

  * `s = "abc"`
      * Output: 3 ( "a", "b", "c")
  * `s = "aaa"`
      * Output: 6 ( "a" (index 0), "a" (index 1), "a" (index 2), "aa" (index 0), "aa" (index 1), "aaa" (index 0))

### Approach (How to do it)

This problem can also be solved using DP or "Expand Around Center" method. The "Expand Around Center" is often simpler to implement and conceptually straightforward for counting.

**Method 1: Dynamic Programming (Similar to Longest Palindromic Substring)**

1.  **Define `dp` table:** `boolean[][] dp = new boolean[n][n]` where `n` is `s.length()`.
      * `dp[i][j]` will be `true` if `s[i...j]` is a palindrome.
2.  **Initialize `count = 0`.**
3.  **Fill DP table:**
      * **Single characters:** For `i` from `0` to `n-1`, `dp[i][i] = true`. Increment `count`.
      * **Two characters:** For `i` from `0` to `n-2`, if `s.charAt(i) == s.charAt(i+1)`, `dp[i][i+1] = true`. Increment `count`.
      * **Lengths 3 to n:** For `len` from `3` to `n`, iterate `i` from `0` to `n-len`. `j = i + len - 1`.
          * If `s.charAt(i) == s.charAt(j) && dp[i+1][j-1]` is true, then `dp[i][j] = true`. Increment `count`.

**Method 2: Expand Around Center (More Efficient and Simpler)**

This method iterates through every possible "center" of a palindrome and expands outwards to count them.
Palindromes can have two types of centers:

1.  **Single character center:** Like "aba" (`b` is center).
2.  **Two character center:** Like "abba" (`bb` is center).

Algorithm:

1.  Initialize `count = 0`.

2.  Iterate through `i` from `0` to `n-1` (where `n` is `s.length()`):

      * **For odd length palindromes (center is `i`):**
          * Call `expandAroundCenter(s, i, i)`. Add the result to `count`.
      * **For even length palindromes (center is `i` and `i+1`):**
          * Call `expandAroundCenter(s, i, i + 1)`. Add the result to `count`.

3.  **`expandAroundCenter(s, left, right)` Helper Function:**

      * This function takes a string `s` and two pointers `left` and `right` (representing the initial center).
      * Initialize `palindromesFound = 0`.
      * While `left >= 0` and `right < s.length()` and `s.charAt(left) == s.charAt(right)`:
          * `palindromesFound++` (because `s[left...right]` is a palindrome)
          * `left--`
          * `right++`
      * Return `palindromesFound`.

### Solution (The Way to Solve)

Hum "Expand Around Center" approach ka use karte hain. Har character ko ek potential palindrome ke single center ke roop mein treat karte hain, aur har do adjacent characters ko ek potential palindrome ke double center ke roop mein treat karte hain. Ek helper function `expandAroundCenter` banate hain jo diye gaye center se bahar ki taraf expand hota hai jab tak characters match karte hain, aur jitne palindromes milte hain unhein count karta hai. Main function `expandAroundCenter` ko har possible single aur double center ke liye call karta hai aur total count return karta hai.

### Code

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        int totalPalindromes = 0;

        // Iterate through each character, treating it as a center for odd-length palindromes
        // and treating the space between it and the next character as a center for even-length palindromes.
        for (int i = 0; i < n; i++) {
            // Case 1: Odd length palindromes (e.g., "aba"), center is at 'i'
            totalPalindromes += expandAroundCenter(s, i, i);

            // Case 2: Even length palindromes (e.g., "abba"), center is between 'i' and 'i+1'
            totalPalindromes += expandAroundCenter(s, i, i + 1);
        }

        return totalPalindromes;
    }

    // Helper function to expand around a center and count palindromes
    private int expandAroundCenter(String s, int left, int right) {
        int count = 0;
        // Expand outwards as long as characters match and indices are within bounds
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            count++; // Found a palindrome
            left--;  // Move left pointer inwards
            right++; // Move right pointer outwards
        }
        return count;
    }
}
```

-----

## 91\. Decode Ways

**Decode Ways** ek Dynamic Programming problem hai jismein humein ek encoded message ko decode karne ke total ways count karne hote hain.

-----

### Description/Overview

Aapko ek string `s` diya gaya hai jismein sirf digits hain. Is string ko ek message ke roop mein decode karna hai, jahan:

  * `'A'` ko `1` se map kiya gaya hai.
  * `'B'` ko `2` se map kiya gaya hai.
  * ...
  * `'Z'` ko `26` se map kiya gaya hai.

Aapko total number of ways find karne hain jisse given `s` ko decode kiya ja sake.
**Constraints:**

  * Leading zeros invalid hain (e.g., "06" is invalid, "10" is valid).
  * Double-digit decodings 10-26 ke beech honi chahiye.

For example:

  * `s = "12"`
      * `12` can be decoded as `AB` (1 2) or `L` (12). Total 2 ways.
  * `s = "226"`
      * `226` can be decoded as `BZ` (2 26), `VF` (22 6), `BBF` (2 2 6). Total 3 ways.
  * `s = "0"`
      * Output: 0 (Invalid decoding)
  * `s = "06"`
      * Output: 0 (Invalid decoding, leading zero for '6')

### Approach (How to do it)

This is a classic DP problem.

1.  **Define `dp` array:** Let `dp[i]` be the number of ways to decode the substring `s[0...i-1]` (i.e., substring of length `i`).

      * `dp` array ki size `n + 1` hogi.

2.  **Base Cases:**

      * `dp[0] = 1`: Empty string ko decode karne ka 1 way hai (represents the base for multiplication).
      * `dp[1] = 1` if `s.charAt(0) != '0'`. Otherwise `dp[1] = 0` (if first char is '0', it's an invalid start).

3.  **Recursive Relation:** Iterate `i` from `2` to `n`.

      * **Consider single digit decoding:** `s.charAt(i-1)`
          * If `s.charAt(i-1)` is not `'0'`, toh `dp[i]` mein `dp[i-1]` add karo. (Matlab, current digit ko separate letter decode kar sakte hain, aur previous ways ko extend kar sakte hain).
      * **Consider two digit decoding:** `s.substring(i-2, i)`
          * Convert this substring to an integer `twoDigitNum`.
          * If `twoDigitNum` is between `10` and `26` (inclusive), toh `dp[i]` mein `dp[i-2]` add karo. (Matlab, current aur previous digit ko combine kar ke ek letter decode kar sakte hain, aur `i-2` tak ke ways ko extend kar sakte hain).

4.  **Final Result:** `dp[n]`.

### Solution (The Way to Solve)

Hum bottom-up Dynamic Programming approach use karte hain. Ek `dp` array banate hain jahan `dp[i]` ka matlab hai string ke pehle `i` characters ko decode karne ke tareeqe. `dp[0]` ko 1 (empty string ka 1 way) aur `dp[1]` ko 1 set karte hain agar pehla character '0' nahi hai. Loop `i = 2` se `n` tak chala kar, do cases consider karte hain:

1.  **Single digit decode:** Agar `s.charAt(i-1)` '0' nahi hai, toh `dp[i]` mein `dp[i-1]` add karte hain.
2.  **Two digits decode:** Agar `s.substring(i-2, i)` (pichle do digits) `10` se `26` ke beech hai, toh `dp[i]` mein `dp[i-2]` add karte hain.
    Final answer `dp[n]` hoga.

### Code

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        if (n == 0 || (n == 1 && s.charAt(0) == '0')) {
            return 0; // Empty string or single '0' cannot be decoded
        }

        // dp[i] will store the number of ways to decode substring s[0...i-1]
        // Size n+1 because dp[0] for empty string, and dp[n] for full string
        int[] dp = new int[n + 1];

        // Base cases
        dp[0] = 1; // Represents 1 way to decode an empty string (for multiplication purposes)
                   // Or, the way to reach "before the first character"

        // dp[1]: Ways to decode the first character
        if (s.charAt(0) == '0') {
            dp[1] = 0; // '0' cannot be decoded alone
        } else {
            dp[1] = 1; // '1'-'9' can be decoded in 1 way
        }

        // Fill DP table for i from 2 to n
        for (int i = 2; i <= n; i++) {
            // Option 1: Decode current digit s.charAt(i-1) as a single digit
            int oneDigit = Integer.parseInt(s.substring(i - 1, i)); // s.charAt(i-1)
            if (oneDigit >= 1 && oneDigit <= 9) { // If valid single digit (not '0')
                dp[i] += dp[i - 1]; // Add ways from previous state
            }

            // Option 2: Decode last two digits s.substring(i-2, i) as a two-digit number
            int twoDigits = Integer.parseInt(s.substring(i - 2, i)); // s.charAt(i-2) and s.charAt(i-1)
            if (twoDigits >= 10 && twoDigits <= 26) { // If valid two-digit number (10-26)
                dp[i] += dp[i - 2]; // Add ways from two states back
            }
        }

        return dp[n]; // Result for the entire string
    }
}
```

-----

## 322\. Coin Change (for minimum coins)

**Coin Change (Minimum Coins)** ek Dynamic Programming problem hai jismein humein given coins se ek amount banane ke liye minimum number of coins find karne hote hain.

-----

### Description/Overview

Aapko ek integer array `coins` diya gaya hai jo different denominations ke coins ko represent karta hai, aur ek integer `amount` diya gaya hai. Aapko find karna hai ki `amount` ko complete karne ke liye **minimum number of coins** kitne chahiye. Agar `amount` ko un coins se banaya nahi ja sakta, toh `-1` return karo.
Aap har type ke coin ko **kitni bhi baar** use kar sakte ho.

For example:

  * `coins = [1, 2, 5], amount = 11`
      * Output: 3 (11 = 5 + 5 + 1)
  * `coins = [2], amount = 3`
      * Output: -1 (3 ko 2 ke coins se nahi bana sakte)
  * `coins = [1], amount = 0`
      * Output: 0 (0 amount ke liye 0 coins)

### Approach (How to do it)

This is a classic DP problem (unbounded knapsack type).

1.  **Define `dp` array:** Let `dp[i]` be the minimum number of coins needed to make amount `i`.

2.  **Initialize `dp` array:**

      * `dp` array ki size `amount + 1` hogi.
      * Initialize `dp[0] = 0` (0 amount ke liye 0 coins).
      * Baki saare `dp[i]` values ko `infinity` (ya `amount + 1` jaisi badi value) se initialize karo. Kyunki `amount + 1` se zyaada coins kabhi nahi lagenge (agar `amount` 1 hai, toh max 1 coin, agar amount 100 aur coins 1 hai toh max 100 coins).

3.  **Iterate and Update:**

      * Loop `i` from `1` to `amount`: (Yeh outer loop amounts ke liye hai)
          * For each `i`, loop through each `coin` in `coins` array: (Yeh inner loop available coins ke liye hai)
              * If `coin <= i`:
                  * `dp[i] = min(dp[i], dp[i - coin] + 1)`
                  * Explanation: `dp[i - coin]` means minimum coins to make `i - coin` amount. Agar hum `i - coin` amount bana sakte hain, toh usme 1 aur coin (current `coin`) add karke `i` amount ban jayega. Hum minimum value lenge un sab `dp[i - coin] + 1` options mein se.

4.  **Final Result:**

      * Return `dp[amount]` if `dp[amount]` is still not `infinity` (or `amount + 1`).
      * Otherwise, return `-1` (amount cannot be made).

### Solution (The Way to Solve)

Hum bottom-up Dynamic Programming approach use karte hain. Ek `dp` array banate hain jahan `dp[i]` ka matlab hai amount `i` banane ke liye required minimum coins. `dp[0]` ko 0 set karte hain aur baki sabhi `dp` values ko ek badi value (infinity) se initialize karte hain. Fir, outer loop `i` ko `1` se `amount` tak iterate karta hai. Har `i` ke liye, inner loop saare available `coins` ko check karta hai. Agar `coin <= i`, toh hum `dp[i]` ko `min(dp[i], dp[i - coin] + 1)` se update karte hain. Iska matlab hai ki `i` amount banane ke liye, hum ya toh current `dp[i]` value ko rakh sakte hain ya `i - coin` amount bana kar usme ek extra `coin` add kar sakte hain. Final answer `dp[amount]` hoga agar woh infinity nahi hai, warna `-1`.

### Code

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        // dp[i] will store the minimum number of coins needed to make amount i
        // Initialize with amount + 1, which acts as infinity
        // Because the maximum number of coins needed would be 'amount' (if all coins are 1)
        // so amount + 1 means it's unreachable
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1); // Initialize with a value larger than any possible valid count

        // Base case: 0 amount needs 0 coins
        dp[0] = 0;

        // Iterate through all amounts from 1 to 'amount'
        for (int i = 1; i <= amount; i++) {
            // For each amount 'i', iterate through all available coins
            for (int coin : coins) {
                // If the current coin can be used to form amount 'i'
                // (i.e., 'i' is greater than or equal to the coin's value)
                if (coin <= i) {
                    // dp[i] = min(current dp[i], dp[amount_remaining_after_using_this_coin] + 1_for_this_coin)
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }

        // If dp[amount] is still amount + 1, it means 'amount' cannot be formed
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

-----

## 152\. Maximum Product Subarray

**Maximum Product Subarray** ek Dynamic Programming problem hai jismein humein ek array ke contiguous subarray ka maximum product find karna hota hai.

-----

### Description/Overview

Aapko ek integer array `nums` diya gaya hai. Aapko ek **contiguous non-empty subarray** find karna hai jiska **product maximum** ho, aur us maximum product ko return karna hai.

For example:

  * `nums = [2, 3, -2, 4]`
      * Output: 6 (Subarray `[2, 3]` ka product 6 hai)
  * `nums = [-2, 0, -1]`
      * Output: 0 (Subarray `[0]` ka product 0 hai. `-2,-1` ka product 2 hai, but it's not the maximum from any contiguous subarray including 0).
      * `[0]` is a subarray. The problem states "non-empty subarray". Max product is 0. If there was no 0, then [-2,-1] would be 2.

### Approach (How to do it)

This problem is tricky because of negative numbers. A negative number multiplied by another negative number becomes positive. So, a small negative number could potentially become part of the largest product.
We need to track both **maximum product ending at current index** and **minimum product ending at current index**.

1.  **Define variables:**

      * `max_so_far`: Global maximum product found so far. Initialize with `nums[0]`.
      * `min_ending_here`: Minimum product ending at the current index. Initialize with `nums[0]`.
      * `max_ending_here`: Maximum product ending at the current index. Initialize with `nums[0]`.

2.  **Iterate:** Loop `i` from `1` to `n-1`:

      * `current_num = nums[i]`.
      * **Crucial step:** If `current_num` is negative, `max_ending_here` aur `min_ending_here` swap ho jayenge. (Kyunki ek negative number se multiply karne par max min ban jata hai aur min max ban jata hai).
          * `if (current_num < 0) swap(min_ending_here, max_ending_here);`
      * **Update `max_ending_here`:**
          * `max_ending_here = max(current_num, max_ending_here * current_num)`
          * Explanation: Current `max_ending_here` ya toh current number khud hai (agar pichla product negative ho gaya tha), ya current number ko `max_ending_here` se multiply karke.
      * **Update `min_ending_here`:**
          * `min_ending_here = min(current_num, min_ending_here * current_num)`
          * Explanation: Current `min_ending_here` ya toh current number khud hai, ya current number ko `min_ending_here` se multiply karke.
      * **Update `max_so_far`:**
          * `max_so_far = max(max_so_far, max_ending_here)`

3.  **Final Result:** `max_so_far`.

### Solution (The Way to Solve)

Normal maximum subarray sum ki tarah, jahan hum sirf sum track karte hain, yahan product mein negative numbers ke karan complexity badh jati hai. Agar ek negative number ata hai, toh woh current maximum ko minimum bana sakta hai aur current minimum ko maximum. Isliye, hum do variables track karte hain: `max_ending_here` (current index tak ka maximum product) aur `min_ending_here` (current index tak ka minimum product). Jab hum ek naye number par move karte hain, toh hum `max_ending_here` aur `min_ending_here` ko `current_num`, `max_ending_here * current_num`, aur `min_ending_here * current_num` ke combination se calculate karte hain. Agar `current_num` negative hai, toh `max_ending_here` aur `min_ending_here` ko update karne se pehle swap karte hain. `max_so_far` variable overall maximum product ko track karta hai.

### Code

```java
class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }

        // Initialize variables
        int maxSoFar = nums[0];       // Overall maximum product found
        int minEndingHere = nums[0];  // Minimum product ending at current index
        int maxEndingHere = nums[0];  // Maximum product ending at current index

        // Iterate from the second element
        for (int i = 1; i < n; i++) {
            int currentNum = nums[i];

            // If current number is negative, swap maxEndingHere and minEndingHere
            // because multiplying by a negative number flips their roles
            if (currentNum < 0) {
                int temp = maxEndingHere;
                maxEndingHere = minEndingHere;
                minEndingHere = temp;
            }

            // Update maxEndingHere:
            // It's either the current number itself, or current number multiplied by previous max
            maxEndingHere = Math.max(currentNum, maxEndingHere * currentNum);

            // Update minEndingHere:
            // It's either the current number itself, or current number multiplied by previous min
            minEndingHere = Math.min(currentNum, minEndingHere * currentNum);

            // Update global maximum product
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }

        return maxSoFar;
    }
}
```

-----

## 139\. Word Break

**Word Break** ek Dynamic Programming problem hai jismein humein check karna hota hai ki kya ek string ko dictionary words ke space-separated sequence mein segment kiya ja sakta hai.

-----

### Description/Overview

Aapko ek non-empty string `s` aur ek dictionary `wordDict` diya gaya hai jismein non-empty words hain. Aapko determine karna hai ki kya `s` ko dictionary words ke space-separated sequence mein segment kiya ja sakta hai.
Same dictionary word ko **multiple times** reuse kar sakte ho.
Assume dictionary mein koi duplicate words nahi hain.

For example:

  * `s = "leetcode", wordDict = ["leet", "code"]`
      * Output: `true` ("leet code")
  * `s = "applepenapple", wordDict = ["apple", "pen"]`
      * Output: `true` ("apple pen apple")
  * `s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]`
      * Output: `false`

### Approach (How to do it)

This is a classic DP problem.

1.  **Define `dp` array:**

      * `boolean[] dp = new boolean[n + 1]` where `n` is `s.length()`.
      * `dp[i]` will be `true` if the first `i` characters of `s` (i.e., `s[0...i-1]`) can be segmented into dictionary words, `false` otherwise.

2.  **Base Case:**

      * `dp[0] = true` (Empty string can always be segmented, it's our starting point for valid prefixes).

3.  **Iterate and Update:**

      * Loop `i` from `1` to `n` (outer loop, representing end index of substring being considered):
          * Loop `j` from `0` to `i-1` (inner loop, representing start index of potential last word):
              * If `dp[j]` is `true` (matlab `s[0...j-1]` already segment ho chuka hai) AND
              * If `s.substring(j, i)` (matlab `s[j...i-1]`) dictionary mein present hai:
                  * Then `dp[i] = true`.
                  * `break` the inner loop (kyunki `dp[i]` true ho gaya, aage check karne ki zaroorat nahi).

4.  **Final Result:** `dp[n]`.

**Optimization:** Convert `wordDict` into a `HashSet` for `O(1)` average time complexity lookups.

### Solution (The Way to Solve)

Hum bottom-up Dynamic Programming approach use karte hain. Ek boolean array `dp` banate hain jahan `dp[i]` true hoga agar `s` ke pehle `i` characters ko dictionary words mein break kiya ja sakta hai. `dp[0]` ko true set karte hain (empty string valid hai). Outer loop `i` ko `1` se `n` tak iterate karta hai (current substring ki end position). Inner loop `j` ko `0` se `i-1` tak iterate karta hai (potential split point). Agar `dp[j]` true hai (matlab `s[0...j-1]` tak segment ho chuka hai) aur `s.substring(j, i)` dictionary mein hai, toh `dp[i]` ko true set karte hain. Dictionary lookups faster banane ke liye `wordDict` ko `HashSet` mein convert karte hain. Final answer `dp[n]` hoga.

### Code

```java
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays; // For testing purpose, not part of final algo

class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();

        // Convert wordDict to a HashSet for O(1) average time complexity lookups
        Set<String> wordSet = new HashSet<>(wordDict);

        // dp[i] will be true if s[0...i-1] can be segmented
        boolean[] dp = new boolean[n + 1];

        // Base case: empty string can be segmented
        dp[0] = true;

        // Iterate through all possible end points of a substring
        for (int i = 1; i <= n; i++) {
            // Iterate through all possible start points of the last word in the segment
            for (int j = 0; j < i; j++) {
                // If s[0...j-1] can be segmented (dp[j] is true)
                // AND the substring s[j...i-1] (from index j to i-1) is in the dictionary
                if (dp[j] && wordSet.contains(s.substring(j, i))) {
                    dp[i] = true; // Then s[0...i-1] can be segmented
                    break;        // Once true, no need to check further for this 'i'
                }
            }
        }

        // The final result is whether the entire string s (s[0...n-1]) can be segmented
        return dp[n];
    }
}
```

-----

## 300\. Longest Increasing Subsequence

**Longest Increasing Subsequence (LIS)** ek Dynamic Programming problem hai jismein humein ek unsorted array mein longest increasing subsequence ki length find karni hoti hai.

-----

### Description/Overview

Aapko ek integer array `nums` diya gaya hai. Aapko return karna hai **longest increasing subsequence** ki length.
A subsequence is derived from an array by deleting some or no elements without changing the order of the remaining elements.
An increasing subsequence means `a1 < a2 < ... < ak` where `a` elements are part of the original array and maintain their relative order.

For example:

  * `nums = [10, 9, 2, 5, 3, 7, 101, 18]`
      * LIS: `[2, 3, 7, 101]` or `[2, 3, 7, 18]`
      * Output: 4 (length)
  * `nums = [0, 1, 0, 3, 2, 3]`
      * LIS: `[0, 1, 2, 3]`
      * Output: 4
  * `nums = [7, 7, 7, 7, 7, 7, 7]`
      * LIS: `[7]`
      * Output: 1

### Approach (How to do it)

This is a classic DP problem. There's also an `O(N log N)` solution using binary search, but the `O(N^2)` DP approach is more intuitive for understanding.

**Dynamic Programming Approach (O(N^2)):**

1.  **Define `dp` array:**

      * `int[] dp = new int[n]` where `n` is `nums.length()`.
      * `dp[i]` will store the length of the **longest increasing subsequence ending at index `i`**.

2.  **Initialize `dp` array:**

      * Har element khud ek LIS hai length 1 ka. So, `dp[i] = 1` for all `i`.
      * Initialize `overall_max_len = 1` (minimum LIS length is 1 for non-empty array).

3.  **Iterate and Update:**

      * Loop `i` from `1` to `n-1` (current element `nums[i]`):
          * Loop `j` from `0` to `i-1` (previous elements `nums[j]`):
              * If `nums[i] > nums[j]` (current element `nums[i]` pichle element `nums[j]` se bada hai, toh hum LIS ko extend kar sakte hain):
                  * `dp[i] = max(dp[i], dp[j] + 1)`
                  * Explanation: `dp[j] + 1` means current `nums[i]` ko `nums[j]` par ending LIS ke end mein add karke ek naya, longer LIS ban raha hai. Hum isse `dp[i]` ka maximum value lenge.
          * `overall_max_len = max(overall_max_len, dp[i])`.

4.  **Final Result:** `overall_max_len`.

### Solution (The Way to Solve)

Hum Dynamic Programming approach use karte hain. Ek `dp` array banate hain jahan `dp[i]` ka matlab hai `nums[i]` par khatam hone wale longest increasing subsequence ki length. Har `dp[i]` ko initially 1 set karte hain. Outer loop `i` ko `1` se `n-1` tak iterate karta hai (current element). Inner loop `j` ko `0` se `i-1` tak iterate karta hai (pichle elements). Agar `nums[i] > nums[j]` hai, toh iska matlab `nums[i]` ko `nums[j]` par khatam hone wale LIS mein add kar sakte hain. Toh `dp[i]` ko `max(dp[i], dp[j] + 1)` se update karte hain. Har `dp[i]` update ke baad, overall maximum length ko bhi track karte hain. Final answer `overall_max_len` hoga.

### Code

```java
import java.util.Arrays;

class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }

        // dp[i] will store the length of the longest increasing subsequence ending at index i
        int[] dp = new int[n];

        // Initialize each dp[i] to 1, because each element itself is an LIS of length 1
        Arrays.fill(dp, 1);

        int overallMaxLen = 1; // Minimum LIS length is 1 for a non-empty array

        // Iterate through the array starting from the second element
        for (int i = 1; i < n; i++) {
            // For each element nums[i], look at all previous elements nums[j] (where j < i)
            for (int j = 0; j < i; j++) {
                // If nums[i] is greater than nums[j], it means nums[i] can extend the LIS ending at nums[j]
                if (nums[i] > nums[j]) {
                    // Update dp[i]: the new LIS ending at nums[i] could be
                    // (LIS ending at nums[j]) + 1 (for nums[i] itself)
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            // Update the overall maximum length found so far
            overallMaxLen = Math.max(overallMaxLen, dp[i]);
        }

        return overallMaxLen;
    }
}
```

-----

## 416\. Partition Equal Subset Sum

**Partition Equal Subset Sum** ek Dynamic Programming problem hai jismein humein check karna hota hai ki kya ek array ko do subsets mein partition kiya ja sakta hai jinka sum equal ho.

-----

### Description/Overview

Aapko ek array `nums` diya gaya hai jismein positive integers hain. Aapko determine karna hai ki kya is array ko do subsets mein partition kiya ja sakta hai jinka **sum equal** ho.

For example:

  * `nums = [1, 5, 11, 5]`
      * Output: `true` (Can be partitioned into `[1, 5, 5]` and `[11]`. Both sum to 11)
  * `nums = [1, 2, 3, 5]`
      * Output: `false` (Total sum is 11, which is odd. Odd sum ko do equal integer subsets mein partition nahi kar sakte)

### Approach (How to do it)

This problem is equivalent to finding if there's a subset in `nums` that sums up to `total_sum / 2`.
If the `total_sum` of all elements in `nums` is odd, toh answer always `false` hoga, kyunki do equal integer sums ka total hamesha even hoga.
If `total_sum` is even, let `target = total_sum / 2`. Ab problem yeh ban gayi hai: "Kya `nums` mein koi subset hai jiska sum `target` ke barabar ho?" This is a classic **Subset Sum Problem**.

**Dynamic Programming Approach (Subset Sum):**

1.  **Calculate Total Sum:** `sum = sum of all elements in nums`.

2.  **Check Parity:** If `sum % 2 != 0`, return `false`.

3.  **Define Target:** `target = sum / 2`.

4.  **Define `dp` array:**

      * `boolean[] dp = new boolean[target + 1]`
      * `dp[j]` will be `true` if it's possible to form a sum `j` using elements from `nums` up to the current element, `false` otherwise.

5.  **Base Case:**

      * `dp[0] = true` (0 sum hamesha empty subset se banaya ja sakta hai).

6.  **Iterate and Update:**

      * Loop `num` through each element in `nums`: (Outer loop, for each item)
          * Loop `j` from `target` down to `num`: (Inner loop, for each possible sum)
              * `dp[j] = dp[j] || dp[j - num]`
              * Explanation:
                  * `dp[j]` (current value) remains `true` if it was already possible to make sum `j` without `num`.
                  * `dp[j - num]` means it was possible to make `j - num`. Agar aisa hai, toh usmein `num` add karke `j` banaya ja sakta hai. So `dp[j]` becomes true.
              * `j` ko `target` se down iterate karna important hai, taaki current `num` ko ek hi baar use kiya ja sake for a particular `dp[j]`.

7.  **Final Result:** `dp[target]`.

### Solution (The Way to Solve)

Pehle, hum `nums` array ka total sum calculate karte hain. Agar total sum odd hai, toh immediately `false` return karte hain. Agar even hai, toh `target` sum ko `total_sum / 2` par set karte hain. Fir, hum ek boolean `dp` array banate hain jahan `dp[j]` true hoga agar sum `j` ko `nums` ke elements se banaya ja sakta hai. `dp[0]` ko true set karte hain. Outer loop `nums` ke har `num` par iterate karta hai. Inner loop `j` ko `target` se `num` tak reverse order mein iterate karta hai. `dp[j]` ko `dp[j] || dp[j - num]` se update karte hain. Yeh check karta hai ki kya sum `j` ko `num` ko include karke (previous `dp[j - num]`) ya `num` ko exclude karke (`dp[j]` current value) banaya ja sakta hai. Final answer `dp[target]` hoga.

### Code

```java
import java.util.Arrays;

class Solution {
    public boolean canPartition(int[] nums) {
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }

        // If total sum is odd, it cannot be partitioned into two equal subsets
        if (totalSum % 2 != 0) {
            return false;
        }

        // The target sum for each subset
        int target = totalSum / 2;

        // dp[j] will be true if sum 'j' can be formed using elements from nums
        boolean[] dp = new boolean[target + 1];

        // Base case: sum 0 can always be formed (by picking no elements)
        dp[0] = true;

        // Iterate through each number in nums
        for (int num : nums) {
            // Iterate from target down to num
            // We iterate backwards to ensure each number is used at most once
            // for the current target 'j'. If we iterated forwards, dp[j-num]
            // might have already been updated by the current 'num', leading to
            // using 'num' multiple times in the same sum calculation.
            for (int j = target; j >= num; j--) {
                // If sum (j - num) was possible, then sum 'j' is also possible
                // by adding the current 'num' to (j - num)
                dp[j] = dp[j] || dp[j - num];
            }
        }

        // The final result is whether the target sum can be formed
        return dp[target];
    }
}
```
