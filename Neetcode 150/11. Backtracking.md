## 78\. Subsets

Subsets ek backtracking problem hai jismein humein ek array ke saare possible subsets (power set) generate karne hote hain.

-----

### Description/Overview

Imagine karo ki tumhare paas ek array hai jismein **unique integers** hain (jaise `[1, 2, 3]`). Tumhein is array ke **saare possible subsets** ya "power set" nikalne hain. Ek subset ka matlab hai ki original array ke elements ka koi bhi combination, including empty set aur pura set. Order matter nahi karta.

For example: `nums = [1,2,3]` ke subsets honge:
`[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]`

Is problem ko solve karne ke liye hum **Backtracking** ya **Iterative** approach ka use kar sakte hain. Backtracking zyaada intuitive hai.

### Approach (Pahunch) (Backtracking)

Backtracking ek recursive technique hai jismein hum solution space ko explore karte hain. Jab hum ek path par jaate hain aur dekhte hain ki woh solution nahi dega, toh hum "backtrack" karte hain aur doosra path explore karte hain.

1.  **Base Case:** Jab hum array ke end tak pahunch jaate hain, toh current combination ek valid subset hota hai, use result list mein add kar do.
2.  **Recursive Step (Choice/Explore/Unchoice):**
      * Har element ke liye do choices hain:
          * **Include** current element: Current element ko apne temporary subset list mein add karo, aur recursion ko next element par call karo.
          * **Exclude** current element: Current element ko ignore karo, aur recursion ko next element par call karo.
      * Recursion call return hone ke baad, agar current element ko include kiya tha, toh use temporary list se **remove (unchoice/backtrack)** kar do. Yeh step zaroori hai taaki agle paths ke liye list saaf ho.

### Solution (Hal)

Hum ek recursive function banate hain jo `nums` array aur current index ko track karta hai. Har step par, hum decide karte hain ki current element ko subset mein shamil karna hai ya nahi. Saare possible combinations ko explore karte hain. Jab bhi hum array ke end tak pahunchte hain, toh current temporary list ek valid subset hota hai aur use final result list mein add kar dete hain. `backtrack` operation yeh ensure karta hai ki jab hum ek branch explore kar chuke hon, toh list ko previous state par restore kar diya jaaye.

### Code (Code)

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        // Ek temporary list jismein current subset banega
        List<Integer> currentSubset = new ArrayList<>();

        // Helper function ko call karein
        // Parameters: result list, current subset, original array, starting index
        backtrack(result, currentSubset, nums, 0);

        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> currentSubset, int[] nums, int start) {
        // Base Case: Jab hum array ke end tak pahunch gaye
        // Current 'currentSubset' ek valid subset hai, isse result mein add kar do
        result.add(new ArrayList<>(currentSubset)); // Deep copy important hai!

        // Explore choices: Har element ko include ya exclude karo
        for (int i = start; i < nums.length; i++) {
            // Choice 1: Include current element
            currentSubset.add(nums[i]);

            // Explore: Recursively call for next elements
            backtrack(result, currentSubset, nums, i + 1);

            // Backtrack (Unchoice): Current element ko remove karo
            // Taaki doosri branches explore ki ja saken
            currentSubset.remove(currentSubset.size() - 1);
        }
    }
}
```

-----

## 39\. Combination Sum

Combination Sum ek backtracking problem hai jismein humein numbers ke combinations dhundhne hote hain jinka sum target ke barabar ho. Ek number ko multiple times use kar sakte hain.

-----

### Description/Overview

Imagine karo ki tumhare paas positive integers ka ek array `candidates` hai (jismein **duplicates allowed nahi hain**), aur ek `target` sum hai. Tumhein `candidates` mein se numbers ke **saare unique combinations** dhundhne hain, jinka sum `target` ke barabar ho. Ek hi number ko **multiple times** use kiya ja sakta hai.

For example: `candidates = [2,3,6,7], target = 7`
Possible combinations:
`[2,2,3]` (2+2+3 = 7)
`[7]` (7 = 7)

Output mein combinations ka order matter nahi karta, aur unique combinations chahiye.

Is problem ko solve karne ke liye hum **Backtracking** ka use karte hain.

### Approach (Pahunch) (Backtracking)

Backtracking mein hum choices explore karte hain. Yahan par choice yeh hai ki kya current number ko combination mein include karna hai ya nahi, aur kitni baar karna hai.

1.  **Sort Candidates (Optional but Recommended):** `candidates` array ko sort karna helpful ho sakta hai, khaaskar duplicate handling (agar hota) ya optimization ke liye. Yahan unique candidates hain, toh itna critical nahi, but good practice.
2.  **Base Cases:**
      * Agar current `target` `0` ho gaya hai, toh current `combination` ek valid solution hai, use result mein add kar do.
      * Agar current `target` `0` se kam ho gaya hai, toh yeh path invalid hai, backtrack karo.
3.  **Recursive Step (Choice/Explore/Unchoice):**
      * Har number `candidates[i]` ke liye, hum use current `combination` mein add karte hain, `target` ko `candidates[i]` se kam karte hain, aur recursion ko call karte hain.
      * **Key Difference from Subsets:** Kyunki hum ek number ko multiple times use kar sakte hain, recursive call `i` (current index) se shuru hogi, na ki `i+1` se.
      * Recursion call return hone ke baad, current number ko `combination` se **remove (backtrack)** kar do.

### Solution (Hal)

Hum ek recursive helper function banate hain jo `candidates` array, `target`, current `combination` list, aur current `index` ko track karta hai. Har step par, hum `candidates[index]` ko current `combination` mein add karne ki koshish karte hain, aur `target` ko update karte hain. Agar `target` `0` ho jaata hai, toh humein ek valid combination mil gaya. Agar `target` negative ho jaata hai, toh yeh path invalid hai. Kyunki ek number ko multiple times use kar sakte hain, next recursive call current `index` se hi shuru hoti hai. Backtracking `remove` operation se previous state restore karta hai.

### Code (Code)

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentCombination = new ArrayList<>();

        // Sort candidates. Optional but can help in some cases and doesn't hurt.
        // Also helps if we want to handle duplicates in a different problem.
        Arrays.sort(candidates);

        // Call the backtracking helper function
        // Parameters: result list, current combination, candidates array,
        // target sum, starting index
        backtrack(result, currentCombination, candidates, target, 0);

        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> currentCombination,
                           int[] candidates, int remainingTarget, int start) {
        // Base Case 1: Target achieved
        if (remainingTarget == 0) {
            result.add(new ArrayList<>(currentCombination)); // Deep copy
            return;
        }

        // Base Case 2: Target exceeded (invalid path)
        if (remainingTarget < 0) {
            return;
        }

        // Explore choices: Har candidate ko try karo
        for (int i = start; i < candidates.length; i++) {
            // Pruning: Agar current candidate remainingTarget se bada hai,
            // toh aage ke candidates bhi bade honge (kyunki sorted hai), so stop.
            if (candidates[i] > remainingTarget) {
                break;
            }

            // Choice: Current candidate ko combination mein add karo
            currentCombination.add(candidates[i]);

            // Explore: Recursively call with updated target
            // Start from 'i' (not i+1) because same number can be used multiple times
            backtrack(result, currentCombination, candidates, remainingTarget - candidates[i], i);

            // Backtrack (Unchoice): Current candidate ko remove karo
            currentCombination.remove(currentCombination.size() - 1);
        }
    }
}
```

-----

## 40\. Combination Sum II

Combination Sum II bhi backtracking problem hai, lekin yahan har number ko sirf ek baar use kar sakte hain, aur input array mein duplicates ho sakte hain.

-----

### Description/Overview

Tumhein positive integers ka ek array `candidates` diya gaya hai (jismein **duplicates ho sakte hain**), aur ek `target` sum. Tumhein `candidates` mein se numbers ke **saare unique combinations** dhundhne hain, jinka sum `target` ke barabar ho. Yahan, `candidates` array ke har number ko **sirf ek baar** use kar sakte hain **har combination mein**. Solutions mein duplicate combinations nahi hone chahiye.

For example: `candidates = [10,1,2,7,6,1,5], target = 8`
Possible combinations (after sorting: `[1,1,2,5,6,7,10]`):
`[1,1,6]`
`[1,2,5]`
`[1,7]`
`[2,6]`

Output mein combinations ka order matter nahi karta, aur unique combinations chahiye.

Is problem ko solve karne ke liye bhi hum **Backtracking** ka use karte hain, but with an important modification for duplicate handling.

### Approach (Pahunch) (Backtracking with Duplicate Handling)

1.  **Sort Candidates (Mandatory):** `candidates` array ko sort karna **bahut zaroori hai** duplicates ko handle karne ke liye.
2.  **Base Cases:**
      * Agar current `target` `0` ho gaya hai, toh current `combination` ek valid solution hai, use result mein add kar do.
      * Agar current `target` `0` se kam ho gaya hai, toh yeh path invalid hai, backtrack karo.
3.  **Recursive Step (Choice/Explore/Unchoice) with Duplicate Logic:**
      * Har number `candidates[i]` ke liye:
          * **Duplicate Handling Logic:** Agar current `i` `start` se bada hai, aur `candidates[i]` `candidates[i-1]` ke barabar hai, toh is `candidates[i]` ko skip kar do. Kyunki humne `candidates[i-1]` ko already process kar liya hoga, aur `candidates[i]` ko process karne se duplicate combination banega. Yeh tabhi kaam karega jab array sorted ho.
          * Current `candidates[i]` ko `combination` mein add karo.
          * `target` ko `candidates[i]` se kam karo.
          * Recursion ko call karo, lekin `start` index `i+1` hoga, kyunki har number ko **sirf ek baar** use kar sakte hain.
          * Recursion call return hone ke baad, current number ko `combination` se **remove (backtrack)** kar do.

### Solution (Hal)

Hum `candidates` array ko sort karte hain. Fir ek recursive helper function banate hain jo `candidates` array, `target`, current `combination` list, aur current `index` ko track karta hai. Key difference yahan duplicate handling mein hai: `for` loop ke andar `if (i > start && candidates[i] == candidates[i-1]) continue;` statement yeh ensure karti hai ki hum ek hi value ko multiple times consider na karein jab woh array mein consecutive duplicates ke roop mein aati hai. Har number ko sirf ek baar use karne ke liye, next recursive call `index + 1` se shuru hoti hai.

### Code (Code)

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentCombination = new ArrayList<>();

        // IMP: Sort the candidates array to handle duplicates correctly
        Arrays.sort(candidates);

        // Call the backtracking helper function
        backtrack(result, currentCombination, candidates, target, 0);

        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> currentCombination,
                           int[] candidates, int remainingTarget, int start) {
        // Base Case 1: Target achieved
        if (remainingTarget == 0) {
            result.add(new ArrayList<>(currentCombination)); // Deep copy
            return;
        }

        // Base Case 2: Target exceeded (invalid path)
        if (remainingTarget < 0) {
            return;
        }

        // Explore choices
        for (int i = start; i < candidates.length; i++) {
            // IMP: Duplicate Handling for Combination Sum II
            // Skip current element if it's a duplicate of the previous one
            // and we are not taking it from the very first position (start)
            if (i > start && candidates[i] == candidates[i - 1]) {
                continue;
            }

            // Pruning: Agar current candidate remainingTarget se bada hai,
            // toh aage ke candidates bhi bade honge (kyunki sorted hai), so stop.
            if (candidates[i] > remainingTarget) {
                break;
            }

            // Choice: Current candidate ko combination mein add karo
            currentCombination.add(candidates[i]);

            // Explore: Recursively call with updated target
            // Start from 'i + 1' because each number can be used only once
            backtrack(result, currentCombination, candidates, remainingTarget - candidates[i], i + 1);

            // Backtrack (Unchoice): Current candidate ko remove karo
            currentCombination.remove(currentCombination.size() - 1);
        }
    }
}
```

-----

## 46\. Permutations

Permutations ek backtracking problem hai jismein humein ek array ke saare possible permutations (orderings) generate karne hote hain.

-----

### Description/Overview

Imagine karo ki tumhare paas unique integers ka ek array `nums` hai (jaise `[1, 2, 3]`). Tumhein is array ke elements ke **saare possible permutations** (yani har possible ordering) generate karne hain. Order yahan matter karta hai.

For example: `nums = [1,2,3]` ke permutations honge:
`[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]`

Is problem ko solve karne ke liye hum **Backtracking** ka use karte hain.

### Approach (Pahunch) (Backtracking)

Permutations generate karne ke liye, hum har step par available elements mein se ek ko choose karte hain, use permutation mein add karte hain, aur phir remaining elements par recursively call karte hain.

1.  **Base Case:** Jab current `permutation` ki length `nums` array ki length ke barabar ho jati hai, toh humein ek complete permutation mil gaya hai, use result list mein add kar do.
2.  **Recursive Step (Choice/Explore/Unchoice):**
      * Har `num` ke liye `nums` array mein:
          * Check karo ki kya `num` current `permutation` mein pehle se present hai (`visited` array ya `contains` check in list). Agar hai, toh skip karo.
          * Agar `num` present nahi hai:
              * `num` ko current `permutation` mein add karo.
              * `num` ko `visited` mark karo.
              * Recursively `backtrack` call karo.
              * Recursion call return hone ke baad: `num` ko `permutation` se **remove (unchoice/backtrack)** karo, aur `visited` mark ko remove karo.

### Solution (Hal)

Hum ek recursive helper function banate hain jo `nums` array, current `permutation` list, aur ek `boolean[] visited` array ko track karta hai. `visited` array yeh ensure karta hai ki hum ek hi element ko current permutation mein do baar na use karein. Har step par, hum `nums` array ke har element ko iterate karte hain. Agar woh element `visited` nahi hai, toh use current permutation mein add karte hain, `visited` mark karte hain, aur recursive call karte hain. Base case tab hit hota hai jab `permutation` ki size `nums.length` ke barabar ho jaati hai. Backtracking mein `visited` ko reset karna aur element ko remove karna zaroori hai.

### Code (Code)

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentPermutation = new ArrayList<>();
        // boolean array to keep track of used elements
        boolean[] used = new boolean[nums.length];

        // Call the backtracking helper function
        // Parameters: result list, current permutation, original array,
        // boolean array to mark used elements
        backtrack(result, currentPermutation, nums, used);

        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> currentPermutation,
                           int[] nums, boolean[] used) {
        // Base Case: Jab current permutation ki length nums ki length ke barabar ho gayi
        if (currentPermutation.size() == nums.length) {
            result.add(new ArrayList<>(currentPermutation)); // Deep copy
            return;
        }

        // Explore choices: Har number ko try karo
        for (int i = 0; i < nums.length; i++) {
            // Agar current number pehle se used hai, toh skip karo
            if (used[i]) {
                continue;
            }

            // Choice: Current number ko permutation mein add karo
            currentPermutation.add(nums[i]);
            used[i] = true; // Mark as used

            // Explore: Recursively call
            backtrack(result, currentPermutation, nums, used);

            // Backtrack (Unchoice): Current number ko remove karo
            currentPermutation.remove(currentPermutation.size() - 1);
            used[i] = false; // Mark as unused for other branches
        }
    }
}
```

-----

## 90\. Subsets II

Subsets II ek backtracking problem hai jismein humein ek array ke saare possible unique subsets generate karne hote hain, jabki array mein duplicates ho sakte hain.

-----

### Description/Overview

Imagine karo ki tumhare paas integers ka ek array `nums` hai (jismein **duplicates ho sakte hain**, jaise `[1, 2, 2]`). Tumhein is array ke **saare possible unique subsets** generate karne hain. Duplicate subsets nahi chahiye.

For example: `nums = [1,2,2]` ke unique subsets honge:
`[], [1], [2], [1,2], [2,2], [1,2,2]`
Note: `[2,1]` is same as `[1,2]` so we only need one.

Is problem ko solve karne ke liye hum **Backtracking** ka use karte hain, with a special handling for duplicates, similar to Combination Sum II.

### Approach (Pahunch) (Backtracking with Duplicate Handling)

1.  **Sort Array (Mandatory):** `nums` array ko sort karna **bahut zaroori hai** duplicates ko sahi tareeke se handle karne ke liye.
2.  **Base Case:** Jab hum array ke end tak pahunch jaate hain, toh current combination ek valid subset hota hai, use result list mein add kar do. (Yeh `Subsets` jaisa hi hai).
3.  **Recursive Step (Choice/Explore/Unchoice) with Duplicate Logic:**
      * Har element `nums[i]` ke liye, `start` index se shuru karke:
          * **Duplicate Handling Logic:** Agar current `i` `start` se bada hai, aur `nums[i]` `nums[i-1]` ke barabar hai, toh is `nums[i]` ko skip kar do. Kyunki humne `nums[i-1]` ko already explore kar liya hoga aur `nums[i]` ko explore karne se duplicate subset banega. Yeh tabhi kaam karega jab array sorted ho.
          * **Include** current element: Current element ko `currentSubset` mein add karo. Recursively call `backtrack` for `i+1`.
          * **Exclude** current element: Hum `for` loop ki iteration se hi exclude karte hain. Jab loop `i` se `i+1` par move karega, toh `nums[i]` automatically exclude ho jayega.
      * Recursion call return hone ke baad, agar current element ko include kiya tha, toh use temporary list se **remove (unchoice/backtrack)** kar do.

### Solution (Hal)

Hum `nums` array ko sort karte hain. Fir ek recursive helper function banate hain jo `nums` array, current `currentSubset` list, aur current `start` index ko track karta hai. हर बार जब हम `for` loop में iterate करते हैं, तो हम पहले यह check करते हैं कि क्या current element previous element का duplicate है (और `i > start` भी check करते हैं ताकि हम पहले duplicate element को consider कर सकें). अगर है, तो उसे skip कर देते हैं. फिर हम current element को `currentSubset` में add करके recursive call करते हैं `i+1` index से. Base case में हम हर `currentSubset` को `result` में add करते हैं.

### Code (Code)

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        // IMP: Sort the array to handle duplicates
        Arrays.sort(nums);

        // Call the backtracking helper function
        backtrack(result, currentSubset, nums, 0);

        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> currentSubset, int[] nums, int start) {
        // Base Case: Har call par, currentSubset ek valid unique subset hai
        result.add(new ArrayList<>(currentSubset)); // Deep copy

        // Explore choices
        for (int i = start; i < nums.length; i++) {
            // IMP: Duplicate Handling
            // Agar current element previous element ka duplicate hai AND hum start index se aage hain,
            // toh is duplicate ko skip karo.
            // Ex: [1,2,2], agar humne pehle '2' le liya hai, toh doosre '2' ko agar hum phir se
            // as new choice pick karte hain, toh duplicate sets banenge.
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }

            // Choice: Current element ko include karo
            currentSubset.add(nums[i]);

            // Explore: Recursively call for next elements (i+1, for unique usage)
            backtrack(result, currentSubset, nums, i + 1);

            // Backtrack (Unchoice): Current element ko remove karo
            currentSubset.remove(currentSubset.size() - 1);
        }
    }
}
```

-----

## 79\. Word Search

Word Search ek backtracking/DFS problem hai jismein humein ek 2D grid of characters mein ek word dhundhna hota hai.

-----

### Description/Overview

Imagine karo ki tumhare paas characters ka ek `m x n` grid (`board`) hai, aur ek `word` string hai. Tumhein pata karna hai ki kya `word` grid mein exist karta hai ya nahi. `word` ko adjacent cells (horizontal ya vertical, diagonally nahi) mein characters ko jodd kar banaya ja sakta hai. Ek cell ka character sirf ek baar use ho sakta hai **same word path mein**.

For example:
`board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]`, `word = "ABCCED"`
Output: `true`

`word = "SEE"`
Output: `true`

`word = "ABCB"`
Output: `false` (B ko do baar use nahi kar sakte ek hi path mein)

Is problem ko solve karne ke liye hum **Backtracking** (jo essentially DFS hai) ka use karte hain.

### Approach (Pahunch) (Backtracking / DFS)

Hum grid ke har cell se start karke `word` ko match karne ki koshish karenge. Har step par, hum 4 directions (up, down, left, right) mein explore karenge.

1.  **Main Function:**

      * `board` mein har cell `(r, c)` ko iterate karo.
      * Agar `board[r][c]` `word` ke pehle character (`word.charAt(0)`) se match karta hai, toh `backtrack` helper function ko call karo `(r, c, 0)` index ke saath (0 matlab `word` ka pehla character).
      * Agar `backtrack` `true` return karta hai, toh immediately `true` return kar do.
      * Agar saare starting cells try karne ke baad bhi `true` nahi milta, toh `false` return karo.

2.  **`backtrack(board, word, r, c, wordIndex)` Helper Function:**

      * **Base Case 1:** Agar `wordIndex` `word` ki length ke barabar ho gaya hai, iska matlab hai ki humne poora word successfully match kar liya hai, `true` return karo.
      * **Base Case 2 (Boundary Checks):** Agar `r` ya `c` grid ki boundaries ke bahar hain (`r < 0 || r >= rows || c < 0 || c >= cols`), toh `false` return karo.
      * **Base Case 3 (Character Mismatch):** Agar `board[r][c]` `word.charAt(wordIndex)` se match nahi karta, toh `false` return karo.
      * **Base Case 4 (Visited Cell):** Agar current cell ka character pehle hi visit ho chuka hai (same word path mein), toh `false` return karo. Iske liye hum ek trick use karenge: visited cells ko temporarily mark karenge (e.g., `board[r][c] = '*'`) aur backtrack karte waqt unhe original character par restore karenge.

3.  **Recursive Step (Explore):**

      * Current cell `(r, c)` ke character ko temporarily mark karo (e.g., `char temp = board[r][c]; board[r][c] = '#';` ya `'*'`). Yeh indicate karega ki yeh cell `current path` mein use ho gaya hai.
      * **4 Directions Explore Karo:** Upar, Neeche, Left, Right.
          * `boolean found = backtrack(board, word, r + 1, c, wordIndex + 1) ||`
          * `             backtrack(board, word, r - 1, c, wordIndex + 1) || `
          * `             backtrack(board, word, r, c + 1, wordIndex + 1) || `
          * `             backtrack(board, word, r, c - 1, wordIndex + 1); `
      * **Backtrack (Unmark):** Current cell ke character ko original value par restore karo (`board[r][c] = temp;`). Yeh step bahut zaroori hai taaki doosre paths is cell ko use kar sakein.
      * `found` return karo.

### Solution (Hal)

Hum grid के हर सेल से DFS (backtracking) शुरू करते हैं. DFS function हर बार `word` के next character को मैच करने की कोशिश करता है. अगर current cell `word` के current character से मैच करता है, तो हम उस सेल को "visited" मार्क करके (temporarily बदलकर) उसके 4 neighbors को explore करते हैं. अगर किसी भी neighbor से हमें `word` का बाकी हिस्सा मिल जाता है, तो `true` रिटर्न करते हैं. Backtrack करते समय, हम सेल को उसकी original value पर वापस सेट कर देते हैं ताकि दूसरे पाथ्स उसे यूज़ कर सकें. अगर `word` पूरा मैच हो जाता है, तो `true` रिटर्न होता है.

### Code (Code)

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int rows = board.length;
        int cols = board[0].length;

        // Har cell se DFS shuru karo
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                // Agar current cell word ke pehle character se match karta hai
                if (board[r][c] == word.charAt(0)) {
                    // Backtrack function ko call karo.
                    // current_char_index = 0 (word ka pehla char)
                    if (dfs(board, word, r, c, 0)) {
                        return true; // Agar mil gaya, toh true return karo
                    }
                }
            }
        }
        return false; // Poora grid explore kar liya, word nahi mila
    }

    private boolean dfs(char[][] board, String word, int r, int c, int wordIndex) {
        // Base Case 1: Agar wordIndex poore word ki length tak pahunch gaya,
        // toh word mil gaya hai
        if (wordIndex == word.length()) {
            return true;
        }

        // Base Case 2: Boundary conditions check
        if (r < 0 || r >= board.length || c < 0 || c >= board[0].length) {
            return false;
        }

        // Base Case 3: Character mismatch or already visited (marked as '#')
        if (board[r][c] != word.charAt(wordIndex)) {
            return false;
        }

        // Mark current cell as visited for this path
        // Temporarily change the character to avoid re-visiting in the same path
        char originalChar = board[r][c];
        board[r][c] = '#'; // Mark as visited

        // Explore all 4 possible directions (Up, Down, Left, Right)
        boolean found = dfs(board, word, r + 1, c, wordIndex + 1) || // Down
                        dfs(board, word, r - 1, c, wordIndex + 1) || // Up
                        dfs(board, word, r, c + 1, wordIndex + 1) || // Right
                        dfs(board, word, r, c - 1, wordIndex + 1);   // Left

        // Backtrack: Restore the original character
        // Yeh step bahut zaroori hai taaki doosre paths is cell ko use kar sakein
        board[r][c] = originalChar;

        return found;
    }
}
```

-----

## 131\. Palindrome Partitioning

Palindrome Partitioning ek backtracking problem hai jismein humein ek string ko palindromic substrings mein partition karna hota hai.

-----

### Description/Overview

Imagine karo ki tumhein ek string `s` diya gaya hai. Tumhein `s` ko **partition** karna hai, matlab parts mein divide karna hai, is tarah se ki har part ek **palindrome** ho. Tumhein `s` ke saare possible palindromic partitions return karne hain.

For example: `s = "aab"`
Possible partitions:
`["a","a","b"]`
`["aa","b"]`

Is problem ko solve karne ke liye hum **Backtracking** ka use karte hain.

### Approach (Pahunch) (Backtracking)

Hum string को start से end तक iterate करेंगे, और हर possible prefix को चेक करेंगे कि क्या वो palindrome है. अगर है, तो उसे current partition में add करेंगे और remaining string पर recursive call करेंगे.

1.  **Main Function:**

      * `result` list aur `currentPartition` list banayein.
      * `backtrack` helper function ko call karein `(s, 0)` index ke saath.

2.  **`backtrack(s, start, currentPartition, result)` Helper Function:**

      * **Base Case:** Agar `start` index string `s` ki length ke barabar ho gaya hai, iska matlab hai ki humne poori string ko successfully partition kar diya hai, toh `currentPartition` ko `result` mein add kar do.
      * **Recursive Step (Choice/Explore/Unchoice):**
          * `start` index se leke `s.length() - 1` tak `i` ko iterate karo.
          * Har `i` par, `s.substring(start, i + 1)` (current prefix) ko check karo ki kya woh **palindrome** hai.
          * **`isPalindrome(s, low, high)` Helper Function:** Yeh check karega ki substring `s[low...high]` palindrome hai ya nahi.
          * Agar current prefix palindrome hai:
              * Use `currentPartition` mein add karo.
              * Recursively `backtrack` call karo `(s, i + 1, currentPartition, result)` (next substring `i + 1` se shuru hoga).
              * Recursion call return hone ke baad, current prefix ko `currentPartition` se **remove (unchoice/backtrack)** kar do.

### Solution (Hal)

Hum ek recursive function `backtrack` ka use karte hain. Yeh function string `s` और current `start` index से शुरू होता है. यह `start` से लेकर string के अंत तक हर possible substring को generate करता है. हर substring के लिए, यह `isPalindrome` helper function का उपयोग करके check करता है कि क्या वह एक palindrome है. यदि हां, तो यह उस substring को current partition में add करता है और शेष string के लिए recursive call करता है. जब `start` index string की length के बराबर हो जाता है, तो हमें एक valid partition मिल जाता है, जिसे हम `result` list में add कर देते हैं. Backtrack operation (substring को remove करना) यह सुनिश्चित करता है कि सभी संभावित पाथ्स को explore किया जा सके.

### Code (Code)

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        List<String> currentPartition = new ArrayList<>();

        // Call the backtracking helper function
        // Parameters: result list, current partition, original string, starting index
        backtrack(result, currentPartition, s, 0);

        return result;
    }

    private void backtrack(List<List<String>> result, List<String> currentPartition,
                           String s, int start) {
        // Base Case: Agar start index string ki length tak pahunch gaya,
        // toh currentPartition ek valid partition hai
        if (start == s.length()) {
            result.add(new ArrayList<>(currentPartition)); // Deep copy
            return;
        }

        // Explore choices: Har possible substring ko check karo
        for (int i = start; i < s.length(); i++) {
            // Check if substring s[start...i] is a palindrome
            if (isPalindrome(s, start, i)) {
                // If it's a palindrome, add it to currentPartition
                currentPartition.add(s.substring(start, i + 1));

                // Explore: Recursively call for the rest of the string
                // New start index will be i + 1
                backtrack(result, currentPartition, s, i + 1);

                // Backtrack (Unchoice): Remove the last added substring
                currentPartition.remove(currentPartition.size() - 1);
            }
        }
    }

    // Helper function to check if a substring is a palindrome
    private boolean isPalindrome(String s, int low, int high) {
        while (low < high) {
            if (s.charAt(low) != s.charAt(high)) {
                return false;
            }
            low++;
            high--;
        }
        return true;
    }
}
```

-----

## 17\. Letter Combinations of a Phone Number

Letter Combinations of a Phone Number ek backtracking/recursion problem hai jismein humein phone keypad digits se letter combinations generate karne hote hain.

-----

### Description/Overview

Imagine karo ki tumhein ek string `digits` diya gaya hai jismein digits `2-9` hain. Tumhein **saare possible letter combinations** generate karne hain jo phone number keypad par un digits se corresponding letters ko press karke ban sakte hain. (Jaisa old phones mein hota tha).

Example: `digits = "23"`
`2` maps to `["a", "b", "c"]`
`3` maps to `["d", "e", "f"]`
Output: `["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]`

Is problem ko solve karne ke liye hum **Backtracking** ka use karte hain.

### Approach (Pahunch) (Backtracking)

Hum har digit ke corresponding letters ko iterate karenge, aur unhe current combination mein add karke next digit par recursive call karenge.

1.  **Mapping:** Ek `Map` ya `String[]` array banayein jo digits ko unke corresponding letters se map kare (`'2' -> "abc"`, `'3' -> "def"`, etc.).
2.  **Base Case:** Agar current `combination` ki length input `digits` string ki length ke barabar ho gayi hai, toh ek valid combination mil gaya hai, use result list mein add kar do.
3.  **Recursive Step (Choice/Explore/Unchoice):**
      * Current digit `digits.charAt(index)` ko lo.
      * Us digit ke corresponding letters (`mapping.get(digit)`) ko iterate karo.
      * Har letter `char c` ke liye:
          * `c` ko current `combination` (StringBuilder use kar sakte hain) mein add karo.
          * Recursively `backtrack` call karo `(digits, index + 1, currentCombination, result)`.
          * Recursion call return hone ke baad, `c` ko `currentCombination` se **remove (backtrack)** kar do.

### Solution (Hal)

Hum ek mapping array (ya map) banate hain jo digits को corresponding letters से जोड़ता है. एक recursive function `backtrack` का उपयोग किया जाता है, जो `digits` string, current `index`, current `combination` (जो `StringBuilder` के रूप में है) और `result` list को लेता है. हर recursive call में, यह current `index` पर digit के लिए सभी possible letters को iterate करता है. हर letter को current `combination` में जोड़ता है, और `index + 1` के लिए recursive call करता है. Base case तब होता है जब `combination` की length `digits` की length के बराबर हो जाती है. Backtracking (StringBuilder से last character remove करना) यह सुनिश्चित करता है कि हर branch को स्वतंत्र रूप से explore किया जा सके.

### Code (Code)

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    // Mapping of digits to letters
    private Map<Character, String> digitToLetters = new HashMap<>();

    public Solution() {
        digitToLetters.put('2', "abc");
        digitToLetters.put('3', "def");
        digitToLetters.put('4', "ghi");
        digitToLetters.put('5', "jkl");
        digitToLetters.put('6', "mno");
        digitToLetters.put('7', "pqrs");
        digitToLetters.put('8', "tuv");
        digitToLetters.put('9', "wxyz");
    }

    public List<String> letterCombinations(String digits) {
        List<String> result = new ArrayList<>();
        // Agar digits empty hai, toh empty list return karo
        if (digits == null || digits.isEmpty()) {
            return result;
        }

        // StringBuilder for efficient string building
        StringBuilder currentCombination = new StringBuilder();

        // Call the backtracking helper function
        // Parameters: result list, current combination, digits string, current index
        backtrack(result, currentCombination, digits, 0);

        return result;
    }

    private void backtrack(List<String> result, StringBuilder currentCombination,
                           String digits, int index) {
        // Base Case: Agar current combination ki length digits string ki length ke barabar ho gayi
        if (index == digits.length()) {
            result.add(currentCombination.toString()); // Add the complete combination
            return;
        }

        // Current digit ko lo
        char digit = digits.charAt(index);
        // Us digit ke corresponding letters ko lo
        String letters = digitToLetters.get(digit);

        // Explore choices: Har letter ko try karo
        for (char letter : letters.toCharArray()) {
            // Choice: Current letter ko combination mein add karo
            currentCombination.append(letter);

            // Explore: Recursively call for the next digit
            backtrack(result, currentCombination, digits, index + 1);

            // Backtrack (Unchoice): Current letter ko remove karo
            // Jab recursive call return hoti hai, toh hum current letter ko
            // StringBuilder se remove kar dete hain taaki doosri branches explore ki ja saken
            currentCombination.deleteCharAt(currentCombination.length() - 1);
        }
    }
}
```

-----

## 51\. N-Queens

N-Queens ek classic backtracking problem hai jismein humein N queens ko chessboard par is tarah place karna hota hai ki koi bhi do queens ek doosre ko attack na karein.

-----

### Description/Overview

Imagine karo ki tumhare paas ek `n x n` chessboard hai. Tumhein `n` queens ko is board par place karna hai is tarah se ki koi bhi do queens ek doosre ko attack na karein.

  * Queens ek doosre ko same row, same column, ya same diagonal par attack karti hain.
    Tumhein **saare distinct solutions** return karne hain, jahan har solution board ke configuration ko darshata hai.

For example: `n = 4`
Output (visual representation, actual output would be list of strings):
`[".Q..", "...Q", "Q...", "..Q."]`
`["..Q.", "Q...", "...Q", ".Q.."]`

Is problem ko solve karne ke liye hum **Backtracking** ka use karte hain.

### Approach (Pahunch) (Backtracking)

Hum har row mein ek queen place karne ki koshish karenge. Har column mein place karne ki koshish karte hain, aur agar safe hai, toh next row par recursive call karte hain.

1.  **Data Structures for Tracking Attacks:** Humein efficiently check karna hoga ki kya koi queen attack kar rahi hai ya nahi.

      * `boolean[] colUsed`: Track karega ki kaun se columns use ho chuke hain.
      * `boolean[] diag1`: Track karega ki kaun se "main" diagonals (`row + col`) use ho chuke hain.
      * `boolean[] diag2`: Track karega ki kaun se "anti" diagonals (`row - col + n - 1` ya `row - col + constant_offset`) use ho chuke hain. `n - 1` constant offset is used to shift negative indices to positive. For `n=4`, `row-col` can range from `0-3 = -3` to `3-0 = 3`. So, `row - col + 3` will range from `0` to `6`.

2.  **Main Function:**

      * `result` list of `List<String>` banayein.
      * Ek `char[][] board` banayein, jise initially `.` se fill karein.
      * `backtrack` helper function ko call karein `(board, 0, colUsed, diag1, diag2, result)`.

3.  **`backtrack(board, row, colUsed, diag1, diag2, result)` Helper Function:**

      * **Base Case:** Agar `row` `n` ke barabar ho gaya hai, iska matlab hai ki humne saari `n` queens place kar di hain. Current `board` configuration ko `List<String>` mein convert karo aur `result` mein add kar do.
      * **Recursive Step (Choice/Explore/Unchoice):**
          * Current `row` mein, `0` se `n-1` tak har `col` (column) ko iterate karo.
          * **Safety Check:** Check karo ki kya `(row, col)` par queen place karna safe hai (i.e., `colUsed[col]`, `diag1[row + col]`, `diag2[row - col + n - 1]` saare `false` hain).
          * Agar safe hai:
              * `board[row][col] = 'Q'` set karo.
              * `colUsed[col] = true`, `diag1[row + col] = true`, `diag2[row - col + n - 1] = true` set karo.
              * Recursively `backtrack` call karo `(board, row + 1, ..., result)` (next row ke liye).
              * Recursion call return hone ke baad: **Backtrack (Unchoice):** `board[row][col] = '.'`, aur `colUsed`, `diag1`, `diag2` ko `false` par restore karo.

### Solution (Hal)

N-Queens ko solve karne ke liye, हम एक बैकट्रैकिंग अप्रोच का उपयोग करते हैं, जहाँ हम हर रो में एक क्वीन रखने की कोशिश करते हैं. एक क्वीन को `(row, col)` पर रखने से पहले, हम तीन शर्तों की जांच करते हैं: क्या उस `col` में पहले से कोई क्वीन है, क्या उस `main diagonal` (`row + col`) में कोई क्वीन है, और क्या उस `anti-diagonal` (`row - col`) में कोई क्वीन है. इन जांचों के लिए, हम तीन `boolean` एरेज़ (`colUsed`, `diag1`, `diag2`) का उपयोग करते हैं. यदि `(row, col)` पर एक क्वीन को रखना सुरक्षित है, तो हम उसे बोर्ड पर रखते हैं, संबंधित `boolean` एरेज़ को अपडेट करते हैं, और अगले रो के लिए रिकर्सिवली कॉल करते हैं. जब `row` `N` के बराबर हो जाता है, तो हमें एक समाधान मिल जाता है. बैकट्रैकिंग (बोर्ड से क्वीन को हटाना और `boolean` एरेज़ को रीसेट करना) यह सुनिश्चित करता है कि हम सभी संभावित समाधानों को explore कर सकें.

### Code (Code)

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        // Board ko '.' se initialize karein
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                board[i][j] = '.';
            }
        }

        // Tracking arrays to quickly check for attacks
        boolean[] colUsed = new boolean[n]; // Kiska column used hai
        // diag1: row + col (main diagonal) - range: 0 to 2*n-2
        boolean[] diag1 = new boolean[2 * n - 1];
        // diag2: row - col + n - 1 (anti-diagonal) - range: 0 to 2*n-2
        boolean[] diag2 = new boolean[2 * n - 1];

        // Start backtracking from row 0
        backtrack(result, board, 0, colUsed, diag1, diag2, n);

        return result;
    }

    private void backtrack(List<List<String>> result, char[][] board, int row,
                           boolean[] colUsed, boolean[] diag1, boolean[] diag2, int n) {
        // Base Case: Agar saari N queens place ho gayi hain (last row processed)
        if (row == n) {
            result.add(createBoardState(board, n)); // Current board state ko add karo
            return;
        }

        // Explore choices: Current row mein har column mein queen place karne ki try karo
        for (int col = 0; col < n; col++) {
            // Safety Check: Current position (row, col) par queen rakhna safe hai ya nahi
            if (!colUsed[col] &&            // Is column not used?
                !diag1[row + col] &&        // Is main diagonal not used? (row + col)
                !diag2[row - col + n - 1]) { // Is anti-diagonal not used? (row - col + offset)

                // Place Queen
                board[row][col] = 'Q';
                colUsed[col] = true;
                diag1[row + col] = true;
                diag2[row - col + n - 1] = true;

                // Explore: Recursively call for the next row
                backtrack(result, board, row + 1, colUsed, diag1, diag2, n);

                // Backtrack (Unchoice): Queen ko remove karo
                board[row][col] = '.';
                colUsed[col] = false;
                diag1[row + col] = false;
                diag2[row - col + n - 1] = false;
            }
        }
    }

    // Helper function to convert char[][] board to List<String>
    private List<String> createBoardState(char[][] board, int n) {
        List<String> boardState = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            boardState.add(new String(board[i]));
        }
        return boardState;
    }
}
```
